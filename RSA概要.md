RSA
===
Created Monday 21 March 2016

鉴于已经忘记了RSA的具体概念, 所以听到nil他们讲的东西有点云里雾里, 我简单回顾了一下rsa的概念,  
其实就是读了下<<图解密码学>>里面的相关章节, 简单整理如下, 权当读书笔记, 没有考虑内容流畅性.  

解决密钥配送问题方法：

* 事先共享密钥
* 密钥分配中心
* Diffie-Hellman 密钥交换
* 公钥密码（非对称密码）

攻击点：
公钥来源是否合法

**数学基础-时钟运算**  

a mod b 的另一种说法是 a 以 b 取模  
a mod b = c 的另一种说法是 a 与 c 以 b 为模同余  
a * b mod c = d 是指在模c的"世界"中，  a * b = c， c / b = a，  (世界, 好中二, 我准备改为"次元"一词!)  
a * b mod c = 1 是指在模c的"世界"中， a 和 b 互为倒数，   某个数是否存在倒数和rsa中某个公钥是否存在对应私钥这个问题数直接相关的  
某数 a 在模c的世界中是否存在倒数可以根据其是否与c互质来判断  
a ^ b mod c 是时钟运算中的乘方， 已知a， c 求b的过程称为离散对数, 求离散对数非常耗时， Diffie-Hellman 密钥交换协议以及   ElGameal 公钥算法就运用了离散对数  

**RSA**  

加密：密文 = 明文 ^ E mod N 
解密：明文 = 密文 ^ D mod N  
(E和N的组合就是公钥， 简写为{E， N}， D和N的组合就是私钥， 简写为{D， N}， 由于N是随公钥公开的， 所以单独称D为私钥也可以)  

**生成密钥对**  

1. 求 N 
生成两个大质数p， q,  使用伪随机数生成器结合素数判定寻找p和q.  
N = p * q  
2. 求 L
L = lcm(p-1, q-1)  注：lcm 是求最小公倍数   
3. 求 E
 1 < E < L, 且 gcd(E， L) = 1 即E 和 L 互质， 使用伪随机数生成器暴力寻找 E, 求gcd可以使用欧几里得辗转相除法.  
之所以加上E和L互质这个条件, 是为了保证一定存在解密时需要使用的 D, 即私钥. 见下方, 求D过程 及上面提到的"某数 a   在模c的世界中是否存在倒数可以根据其是否与c互质来判断" 这句  
4. 求 D
 E * D mod L = 1, 这里验证了前面说的, 某数 a 在模c的世界中是否存在倒数可以根据其是否与c互质来判断.  

**攻击RSA**  

1. 假设 RSA 是这样的, 密文 = 明文 ^ E,  那么 逆运算求明文就是非常简单的求对数问题, 然而 加上 mod N 之后,   求明文则变成了前面提到的离散对数问题, 这是个困难问题.  
2. 暴力枚举 D 也不显示, D 一般非常大  
3. 在RSA 生成密钥对过程中, 由于 E * D mod L = 1, D 是根据这个式子得到的, 那么攻击者如果知道了L, 也就是知道了 p和q,   就可以用同样的方式得到 D. (有一处不解, 求离散对数是困难问题, 那么E * D mod L = 1 为啥就能求出D? 求倒数要简单很多么?)  
4. 对 N 进行质因数分解求出p 和 q, 这也是个困难问题  
5. p和q是通过伪随机数生成器生成的, 如果伪随机数生成器算法很差, 那么可以基于此推测出 p和q.  
6. "求 D" 与 "对N进行质因数分解" 是否等价在数学上还没有证明, 可能存在不需要对N进行质因数分解也可以由E和N求出D的数学方法,   当然现在还不存在.  
7. 中间人攻击, 简而言之, 伪造公钥来源, 解决的办法 就是证书.  


**其他公钥密码**  

1. ElGamal, 利用了 模N世界求离散对数的复杂度. (RSA 也利用了吧, 只不过RSA更侧重于质因数分解的复杂的?)  
2. Rabin, 利用模N世界下求平方根的困难度, 以经证明其与质因数分解困难度是相当的.  
3. 椭圆曲线密码, ECC, 通过将对椭圆曲线上的特定点进行特殊乘法运算来实现, 它利用了这种乘法运算的逆运算非常困难的特性  




